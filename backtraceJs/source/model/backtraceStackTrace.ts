/**
 * Reprresent single stack frame in stack trace
 */
interface IBacktraceStackFrame {
  funcName: string;
  sourceCode?: string;
  library: string;
  line: number;
  column: number;
}

/**
 * Analyse stack trace generated by exception
 * Create Stack Frames and find calling library/program informaiton
 */
export class BacktraceStackTrace {
  public readonly fault: boolean = true;
  public readonly name = 'main';
  public stack: IBacktraceStackFrame[] = [];

  private readonly stackLineRe = /^\s+at (?:([^\s]+) )?\(?(.+):(\d+):(\d+)\)?$/;

  private error: Error;
  constructor(err: Error | string) {
    // handle reports with message
    if (!(err instanceof Error)) {
      err = new Error();
    }
    this.error = err;
    this.parseStackFrames();
  }

  /**
   * Get Json data from Stack trace object
   */
  public toJson() {
    return {
      name: this.name,
      fault: this.fault,
      stack: this.stack,
    };
  }

  /**
   * Start parsing stack frames
   */
  private parseStackFrames(): void {
    const stackTrace = this.error.stack;
    if (!stackTrace) {
      return;
    }
    // get exception lines and remove first line of descrtiption
    const lines = stackTrace.split('\n').slice(1);
    lines.forEach((line) => {
      const match = line.match(this.stackLineRe);
      if (!match || match.length < 4) {
        return;
      }
      const fullPath = match[2];
      const backtraceLibStackFrame =
        fullPath.indexOf('node_modules/backtrace-js') !== -1;
      if (backtraceLibStackFrame) {
        return;
      }
      const stackFrame: IBacktraceStackFrame = {
        funcName: match[1] ? match[1] : 'unknown',
        library: fullPath.substring(fullPath.lastIndexOf('/') + 1),
        line: parseInt(match[3], 10),
        column: parseInt(match[4], 10),
      };

      if (this.stack.length === 0) {
        stackFrame['sourceCode'] = 'main';
      }
      this.stack.push(stackFrame);
    });
  }
}
